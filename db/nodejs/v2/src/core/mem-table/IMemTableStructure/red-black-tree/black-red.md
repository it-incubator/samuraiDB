# Красно-черное дерево (Red-Black Tree)

Реализация сбалансированного двоичного дерева поиска, которое автоматически поддерживает баланс при вставке и удалении элементов.

## Свойства красно-черного дерева

1. Каждый узел либо красный, либо черный
2. Корень всегда черный
3. Все листья (NULL) считаются черными
4. У красного узла оба потомка черные
5. Для каждого узла все простые пути от него до листьев содержат одинаковое число черных узлов

## API

### Конструктор

```typescript
constructor()
```

Создает пустое красно-черное дерево.

### Методы

#### insert(key: TKey, value: TValue): void

Вставляет новый элемент в дерево или обновляет значение существующего ключа.

```typescript
const tree = new RedBlackTree<number, string>();
tree.insert(1, "one");
```

#### delete(key: TKey): void

Удаляет элемент с указанным ключом из дерева.

```typescript
tree.delete(1);
```

#### find(key: TKey): TValue | null

Поиск значения по ключу. Возвращает null, если ключ не найден.

```typescript
const value = tree.find(1);
```

#### print(): void

Выводит визуальное представление дерева в консоль.

```typescript
tree.print();
```

Пример вывода:
```
10(BLACK)
├── 5(RED)
│   ├── 3(BLACK)
│   └── 7(BLACK)
└── 15(RED)
    ├── 13(BLACK)
    └── 17(BLACK)
```

Особенности реализации:

1. Если дерево пустое, выводится сообщение "Empty tree"
2. Для каждого узла выводится его ключ и цвет в скобках
3. Используются специальные символы для отображения связей между узлами:
    - `├──` для левого потомка
    - `└──` для правого потомка
    - `│   ` для вертикальных линий
4. Метод рекурсивно обходит дерево, поддерживая правильные отступы и связи

## Структура узла

```typescript
class TreeNode<TKey, TValue> {
    key: TKey;
    value: TValue;
    color: Color;
    left: TreeNode<TKey, TValue> | null;
    right: TreeNode<TKey, TValue> | null;
    parent: TreeNode<TKey, TValue> | null;
}
```

## Временная сложность

| Операция | В среднем | В худшем случае |
|----------|-----------|-----------------|
| Вставка  | O(log n)  | O(log n)       |
| Удаление | O(log n)  | O(log n)       |
| Поиск    | O(log n)  | O(log n)       |

## Пример использования

```typescript
const tree = new RedBlackTree<number, string>();

// Вставка элементов
tree.insert(10, "десять");
tree.insert(5, "пять");
tree.insert(15, "пятнадцать");

// Поиск элемента
const value = tree.find(5); // "пять"

// Визуализация дерева
tree.print();

// Удаление элемента
tree.delete(5);
```

## Примечания по реализации

- Дерево поддерживает обобщенные типы для ключей и значений
- Автоматически балансируется после вставки и удаления
- Реализует интерфейс IMemTableStructure
- Все операции гарантированно выполняются за O(log n) времени
- Дополнительное пространство O(n)

## Ограничения

- Ключи должны быть сравнимыми (поддерживать операторы <, >, =)
- Не поддерживает дубликаты ключей (при вставке существующего ключа значение обновляется)

## Использование памяти

Каждый узел дерева содержит:
- Ключ и значение
- Цвет (1 бит)
- Три ссылки (на родителя и двух потомков)

Общее использование памяти: O(n), где n - количество элементов в дереве.
